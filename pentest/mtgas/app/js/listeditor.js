// Card list editor
function card_list_edit_n_bottom(zone, dest) {
	var n = prompt_int('How many cards to look ?', 1) ;
	if ( isn(n) && ( n != 0 ) ) {
		n = - n ;
		return card_list_edit(zone, dest, n) ;
	} else
		return n ;
}
function card_list_edit_n(zone, dest, bottom) {
	var n = prompt_int('How many cards to look ?', 1) ;
	if ( isn(n) && ( n != 0 ) )
		return card_list_edit(zone, dest, n) ;
	else
		return n ;
}
function card_list_edit(zone, dest, n) {
	if ( isn(n) && ( n == 0 ) )
		return false ;
	// Unicity
	if ( zone.editor_window != null ) {
		game.infobulle.set('Already open : '+zone.get_name()) ;
		return false ;
	}
	// Dest
	if ( ( ! dest ) || ( dest == null ) )
		if ( zone.type == 'battlefield' )
			dest = zone.player.graveyard ;
		else
			dest = zone.player.battlefield ;
	// Message + first displayed card
	zone.editor_window = document.createElement('div') ;
	var m = 'looks at ' ;
	if ( isn(n) ) { // If user wants to watch only top N cards
		if ( n > 0 ) {
			m += ' top '+n+' cards of ' ;
			zone.editor_window.firstcard = zone.cards[zone.cards.length-n-1] ; // Remember the first card the list shouldn't display
		} else {
			m += ' bottom '+(-n)+' cards of ' ;
			zone.editor_window.firstcard = zone.cards[-n] ; // Remember the first card the list shouldn't display
		}
	}
	m += zone.player.name+'\'s '+zone.type ;
	if ( spectactor )
		message(game.spectators.get(spectactor_id).name+' '+m) ;
	else
		message_send(m) ;
	// Display
	var ol = game.player.lists_opened() + game.opponent.lists_opened() ;
	zone.editor_window.style.right = (300 * ol ) + 'px' ;
	zone.editor_window.classList.add('cardlist') ;
	zone.editor_window.zone = zone.toString() ;
	zone.editor_window.dest = dest.toString() ;
	zone.editor_window.n = n ;
	zone.editor_window.close = function() {
		var div = this ;
		var zone = eval(div.zone) ;
		zone.editor_window = null ;
		div.parentNode.removeChild(div) ;
		m = 'stops looking at '+zone.player.name+'\'s '+zone.type ;
		if ( spectactor )
			message(game.spectators.get(spectactor_id).name+' '+m) ;
		else
			message_send(m) ;
		for ( var i = 0 ; i < zone.cards.length ; i++ ) {
			zone.cards[i].watching = false ; // Reinit watching for all cards in watched zone
			zone.cards[i].load_image() ;
		}
		if ( tmp.checked )
			zone.shuffle() ;
		zone.refresh() ;
	}
		// Header
	var listtool = document.createElement('div') ;
	listtool.classList.add('listtool') ;
	zone.editor_window.appendChild(listtool) ;
			// Button close
	var but_close = create_button('X', function(ev) {
		ev.target.parentNode.parentNode.close() ;
	}, 'Close list', 'but_close') ;
	zone.editor_window.appendChild(but_close) ;
	listtool.appendChild(but_close) ;
			// Title
	var wintitle = zone.get_name() ;
	if ( isn(zone.editor_window.n) ) // If user wants to watch only top N cards
		if ( zone.editor_window.n > 0 )
			wintitle = 'Top '+zone.editor_window.n+' cards of ' + wintitle ;
		else
			wintitle = 'Bottom '+(zone.editor_window-zone.editor_window.n)+' cards of ' + wintitle ;
	var title = create_div(wintitle) ;
	title.title = wintitle+' (drag to move)' ;
	listtool.appendChild(title) ;
	title.draggable = true ;
	function draglist(ev) {
		var offset = parseInt(ev.dataTransfer.getData('offset')) ;
		var left = ev.clientX - offset ;
		ev.dataTransfer.mozSourceNode.parentNode.parentNode.style.left = left + 'px' ;
		return eventStop(ev) ;
	}
	title.addEventListener('dragstart', function(ev) {
		window.addEventListener('dragover', draglist, false) ;
		var c = ev.currentTarget.parentNode.parentNode.getBoundingClientRect() ;
		var offset = ev.clientX - c.left ;
		ev.dataTransfer.clearData() ; // Remove all data auto-generated by browser
		ev.dataTransfer.setData('offset', offset) ;
		return false ;
	}, false) ;
	title.addEventListener('dragend', function(ev) {
		window.removeEventListener('dragover', draglist, false) ;
	}, false) ;
			// Shuffle checkbox
	var checked = ( ( zone.type == 'library' ) && ( ! zone.editor_window.firstcard ) ) ;
	var tmp = create_checkbox('shuffle', checked, 'shuffle', '') ;
	var check_shuffle = create_label(tmp.id, tmp, document.createTextNode('Shuffle')) ;
	check_shuffle.title = 'Shuffle '+zone.type+' when closing this list' ;
	listtool.appendChild(check_shuffle) ;
	if ( ! isn(zone.editor_window.n) ) {
		zone.editor_window.initial_sorting = zone.cards.join(',') ;
		var b_sort_cur = create_button('Current', function(ev) {
			var zone = eval(ev.target.parentNode.parentNode.zone) ;
			var sel = new Selection(zone.editor_window.initial_sorting) ;
			zone.cards = sel.cards ;
			refresh_list(zone) ;
		}, 'Sort list like zone is currently sorted') ;
		listtool.appendChild(b_sort_cur) ;
		var b_sort_deck = create_button('Deck', function(ev) {
			var zone = eval(ev.target.parentNode.parentNode.zone) ;
			zone.cards.sort(sort_deck) ;
			refresh_list(zone) ;
		}, 'Sort list like decklist') ;
		listtool.appendChild(b_sort_deck) ;
		var b_sort_alpha = create_button('Alphabet', function(ev) {
			var zone = eval(ev.target.parentNode.parentNode.zone) ;
			zone.cards.sort(sort_alphabet) ;
			refresh_list(zone) ;
		}, 'Sort list alphabetically') ;
		listtool.appendChild(b_sort_alpha) ;
	}
		// List
	var ul = document.createElement('ul') ;
	ul.id = 'cards' ;
	zone.editor_window.cardlist = ul ;
	zone.editor_window.appendChild(ul) ;
	// Add to document
	document.body.appendChild(zone.editor_window) ;
	ul.style.height = (zone.editor_window.clientHeight-listtool.offsetHeight)+'px' ;
	// List filling
	zone.refresh() ;
	return zone.editor_window ;
}
// Main function : fill list
function refresh_list(zone) {
	var editor_window = zone.editor_window ;
	var dest = eval(editor_window.dest) ;
	var myul = zone.editor_window.cardlist ;
	node_empty(myul) ;
	var cards = zone.cards ;
	// "All" element
	var allli = create_li('Uninitialized', 'all') ;
	allli.title = 'Select an action to apply to every displayed cards in list' ;
	allli.addEventListener('contextmenu', allContextMenu, false) ;
	allli.addEventListener('click', allContextMenu, false) ;
	allli.cards = [] ;
	myul.appendChild(allli) ;
	// List display
	if ( isn(editor_window.n) && ( editor_window.n < 0 ) ) // From bottom
		var disp = false ; // Don't display top cards until first card encountered
	else // From top
		var disp = true ; // Display top cards until first card encountered
	for ( var i = cards.length - 1 ; i >= 0 ; i-- ) { // From topdeck to bottomdeck
		// Watching top/bottom cards
		if ( editor_window.firstcard )
			if ( editor_window.firstcard == cards[i] ) // Next display is the first not-to-display
				if ( editor_window.n < 0 ) { // From bottom
					disp = true ; // Display next cards
					continue ; // But not that one
				} else // From top
					break ; // Stop listing
		if ( ! disp )
			continue ;
		// Create / reuse li
		if ( ! iso(cards[i].li) ) { // No cache, create element
			var myli = create_li(cards[i].get_name(), 'card') ;
			myli.addEventListener('mousedown', listMouseDown, false) ;
			myli.addEventListener('mouseup', listMouseUp, false) ;
			myli.addEventListener('mouseenter', listMouseEnter, false) ;
			myli.addEventListener('mouseleave', listMouseLeave, false) ;
			myli.addEventListener('click', eventStop, false) ;
			myli.addEventListener('dblclick', listDblClick, false) ;
			myli.addEventListener('contextmenu', listContextMenu, false) ;
			myli.title = 'Double click '+cards[i].name+' to send it to '+dest.type ;
			myli.thing = cards[i] ;
			myli.thing.li = myli ; // Cache it
		} else { // Cache exists
			var myli = cards[i].li ; // Use it
			myli.className = 'card' ; // Reinit its class (dragged, draggedover status)
		}
		// Load image
		myli.thing.watching = true ;
		myli.thing.load_image(function(img, myli) {
			myli.style.backgroundImage = 'url(\"'+img.src+'\")' ;
			node_empty(myli) ; // Initial card name
		}, myli) ;
		// Add to ul
		myul.appendChild(myli) ;
		allli.cards.push(myli.thing) ;
	}
	if ( isn(editor_window.n) ) {
		if ( editor_window.n < 0 ) // From bottom
			var nb = - editor_window.n ;
		else
			var nb = cards.length - i - 1 ;
	} else
		var nb = cards.length ;
	allli.textContent = 'On displayed '+nb+' cards ...' ;
}
// Events functions
function listMouseDown(ev) {
	var li = ev.target ;
	var card = li.thing ;
	switch ( ev.button ) {
		case 0 : // Left click
			game.selected.set(card) ;
			drag_init(card) ;
			drag_start() ;
			li.classList.add('dragged') ;
			return eventStop(ev) ; // In div/ul/li, default mousedown action is start text selection, don't want that
			break ;
		case 1 : // Middle button click
			break ;
		case 2 : // Right click
			break ;
	}
}
function listMouseUp(ev) {
	switch ( ev.button ) {
		case 0 : // Left click
			if ( game.drag != null ) {
				var from = game.drag ; // Dragged card
				var to = ev.target.thing ; // Dropped on
				var idx = to.IndexInZone() ;
				if ( from.zone == to.zone )
					from.moveinzone(idx) ;
				else if ( game.drag != null ) {
					idx++ ;
					game.selected.changezone(to.zone, null, idx) ;
				}
				if ( game.drag.li )
					game.drag.li.classList.remove('dragged') ;
				ev.target.classList.remove('draggedover') ;
				drag_stop() ;
			}
			break ;
		case 1 : // Middle button click
			break ;
		case 2 : // Right click
			break ;
	}
}
function listMouseEnter(ev) { // MouseEnter : update "zoom"
	var card = ev.target.thing ;
	card.zoom() ;
	if ( game.drag != null )
		ev.target.classList.add('draggedover') ;
}
function listMouseLeave(ev) { // MouseLeave : cleanup
	ev.target.classList.remove('draggedover') ;
	return eventStop(ev) ;
}
function listDblClick(ev) { // Double click : send to BF
	game.selected.set(ev.target.thing) ;
	var dest = eval(ev.target.parentNode.parentNode.dest) ;
	var visible = null ; // Set to default visibility (not forced true) in order not to sync in default case
	if ( ev.ctrlKey || ev.altKey || ev.shiftKey )
		visible = false ;
	game.selected.changezone(dest, visible) ;
	draw() ;
}
function listContextMenu(ev) {
	var card = ev.target.thing ;
	if ( ! card.selected() ) // Menu on a card that isn't selected
		game.selected.set(card) ; // Select only that one
	return card.menu(ev) ;
}
function allContextMenu(ev) { // Menu called on all displayed li, as they mey have change since opening
	var cards = ev.target.cards ;
	if ( cards.length < 1 )
		return eventStop(ev) ;
	game.selected.set(cards) ; // Use global selection to reuse card menu
	return cards[0].menu(ev) ;
}
